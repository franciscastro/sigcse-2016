\documentclass{sig-alternate-05-2015}

\usepackage{listings}
\usepackage{color}
\usepackage{paralist}
\usepackage{enumitem}
\usepackage{alltt}
\usepackage{float}
\usepackage{xspace}
\usepackage{todonotes}
\usepackage{cleveref}
\usepackage{textcomp}
\usepackage{booktabs}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
  language=Scheme,
  aboveskip=3mm,
  belowskip=3mm,
  % showstringspaces=false,
  columns=fixed, %flexible
  basicstyle={\small\ttfamily},
  % numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  basewidth=0.5em
  % breaklines=true,
  % breakatwhitespace=true,
  % tabsize=3
}

\newcommand{\htdp}{{\sc htdp}\xspace}
\newcommand{\etal}{\mbox{\it et al.\ }}
\def\problemName#1{\emph{#1}\xspace}
\def\Adding{\problemName{Adding Machine}}

\begin{document}

\CopyrightYear{2016} 
\setcopyright{acmlicensed}
\conferenceinfo{SIGCSE '16,}{March 02 - 05, 2016, Memphis, TN, USA}
\isbn{978-1-4503-3685-7/16/03}\acmPrice{\$15.00}
\doi{http://dx.doi.org/10.1145/2839509.2844574}

\title{On the Interplay Between Bottom-Up and \\ Datatype-Driven Program Design}

\numberofauthors{2} 

\author{
% 1st. author
\alignauthor
Francisco Enrique Vicente Castro\\
       \affaddr{Department of Computer Science}\\
       \affaddr{Worcester Polytechnic Institute}\\
       \affaddr{100 Institute Road, Worcester, MA, USA}\\
       \email{fgcastro@wpi.edu}
% 2nd. author
\alignauthor
Kathi Fisler\\
       \affaddr{Department of Computer Science}\\
       \affaddr{Worcester Polytechnic Institute}\\
       \affaddr{100 Institute Road, Worcester, MA, USA}\\
       \email{kfisler@wpi.edu}
}

\maketitle
\begin{abstract}
When students are faced with a programming problem unlike any they have solved before, prior research suggests that they develop code backwards from essential computations in the problem.  Some curricula, however, teach students to first write scaffolding code based on the type of the input data.  How do these two approaches interact?  We gave CS1 students who were taught to write scaffolding code a programming problem unlike any they had seen before.  We found that while students
put essential computations into the scaffolds, they often overuse affordances of the scaffolds in ways that lead to plan-composition errors. We propose that steering students away from on-the-fly decomposition while programming could help avoid some of these errors.
\end{abstract}

% The code below should be generated by the tool at http://dl.acm.org/ccs.cfm
% Please copy and paste the code instead of the example below. 

% Sheridan instructions say we can leave this out
%\vspace{1mm}
%\noindent
%{\bf Categories and Subject Descriptors:} K.3.2 {[Computers and Education]}: {Curriculum}

\vspace{1mm}
\noindent
{\bf Keywords:} Novice programmers; models of code development; plan composition

\section{Introduction}

Most models of how novices program suggest that they use previously learned examples or solutions as starting points for new programs \cite{Pirolli_Anderson_1985,  Pirolli_Anderson_Farrell_1984, Spohrer_Soloway_1989}. What happens, however, when a new problem is sufficiently different that previously-learned examples don't apply? 

In studies with students learning Pascal, Rist \cite{Rist_1989, Rist_1991} determined that novices write down a statement or expression that captures the essence of some program task (the \textit{focus}), then work backwards to integrate this into the overall program.  In contrast, pedagogic approaches such as \textit{How to Design Programs} (henceforth \htdp) aim to be more systematic, teaching students to first write scaffolding code that exploits the structure of input data.  These two perspectives, one a model developed from observing students programming procedurally and one a process designed to scaffold traversal of recursively-defined datatypes (as taught in some CS1 courses that use functional languages), could either complement or interfere with one another.  What role does each play in helping students develop correct solutions to new problems?  What hindrances does each introduce?

This paper explores the interplay of bottom-up programming and datatype-driven design, using Rist's model and \htdp as concrete instances of each.  We report on a study in which \htdp students were given a problem that required program structures they had not yet learned. We video-recorded their sessions, looked for how students used each of focal-expressions and \htdp scaffolds in attempting to solve the problem, and extract insights on the affordances and limitations of each approach.  In part, this work explores how bottom-up programming manifests in functional programming.  In part, it tries to identify ways to leverage each  perspective towards developing pedagogic techniques that help students tackle new programming problems.

\section{Background}

\subsection{Rist's Focal Expansion Model}
\label{sec:rist}

Several papers from the mid 1980's proposed models of how students create new programs by adapting known solutions to similar problems (we review these in \cref{sec:other-rel-work}). Rist's \emph{focal-expansion model} \cite{Rist_1989, Rist_1991} expanded on these to cover situations in which students lacked similar problems on which to build. His model identifies two states that students can enter when encountering a programming problem:

\begin{enumerate}
	\item \textbf{Plan Retrieval}: If a novice knows a solution to a similar problem, she will retrieve it (from memory) and reproduce the code in a top-down fashion.
    \item \textbf{Plan Creation}: If a novice does not know a solution to a similar problem, she will start from a small code fragment for an identified computation within the problem. This code fragment is called the \textit{focus} or \textit{focal computation}. She will then expand the code around the focus in bottom-up fashion to integrate the new code into the rest of the program.
\end{enumerate}

\noindent
When a known solution applies to a more difficult problem, the model predicts that students switch to bottom-up creation mode after retrieval. As a programmer's experience increases, she makes heavier use of retrieval. 

Intuitively, the focus is the essential computation for an identifiable \emph{task} within the program. For the task to sum a sequence of numbers, an expression like \lstinline{sum := sum + n} would be the focus (where \lstinline{n} would be defined subsequently, perhaps by reading the next input from the sequence).  In the problem of averaging a sequence of numbers, there are three focal expressions, one for each of the required tasks of summing the elements, counting the elements, and dividing the sum by the count. Rist's model does not address which focal a student would handle first.  Rather, it claims that one of the expressions \lstinline{sum := sum + n}, \lstinline{count := count + 1}, or \lstinline{average = sum / count} would be written and expanded upon first, rather than more generic code such as ``iteratively read input'' (which would only occur first in retrieval mode).

Rist developed this model from watching students produce code (in Pascal) for problems such as calculating the volume of a box-like house or sorting weights into ascending order. The essence of the model lies in (a) new plan creation starting from a focal computation, and (b) the construction of code being either top-down or bottom-up, depending on whether a plan is being created or retrieved.

\subsection{How to Design Programs}
\label{sec:htdp} 

\textit{How to Design Programs} (\htdp) is a CS1 curriculum that teaches a step-by-step ``recipe'' for designing programs~\cite{htdp}. Its two core ideas are \emph{write test suites first} and \emph{design programs from the shape of the input data}.  A student trained in \htdp first writes down the input and output types of a function, followed by several examples (test cases) of the function's behavior (including both inputs and outputs), followed by a \emph{template} for the function. The template captures code that is dictated by the shape of the data, leaving holes to fill with problem-specific computations. 

As an example, consider a function to determine whether a list of strings contains ``pie''.  A student would first write the type signature (as a comment) and several examples (a.k.a.\ \lstinline{check-expect}s). We present code in Racket, as that is the language used in both our study and the \htdp textbook (though the principles apply more generally).

\begin{lstlisting}
; containsPie? : list-of-string -> boolean
(check-expect (containsPie? empty) false)
(check-expect (containsPie? (list "apple" "pie")) true)
(check-expect (containsPie? (list "bread" "tea")) false)
\end{lstlisting}

\noindent
Next, the student would write the \emph{template}: code that exhausts what is known about the shape of the input data (in this case a list of strings):

\begin{lstlisting}
; containsPie? : list-of-string -> boolean
(define (containsPie? alst)
  (cond [(empty? alst) ... ]
        [(cons? alst) ... (first alst) 
                      ... (containsPie? (rest alst)) ]))
\end{lstlisting}
\label{code:template-example}

\noindent
The template has a conditional that checks whether the list is empty. If it is, the template simply contains a hole for the function's result in that case.  If not, then the list must have both a first element and the subsequent elements (rest).  The latter is itself a list of strings, and hence should also be processed by  \lstinline{containsPie?}.  The template therefore includes a recursive call on the rest of the list.  The template has holes in place of concrete code for combining the first element with the result from the recursive call. Note that nothing in the template is specific to the computation required for \lstinline{containsPie?}: the template simply traverses the input data.

To finish the function, the student fills in the holes with details specific to \lstinline{containsPie?}.  The student can leverage the test cases to do this (details of how to do this are not relevant to this paper).  The next box shows the final code: the student filled in \lstinline{false}, a comparison to the string \lstinline{"pie"}, and the \lstinline{or} operator to complete the function.

\noindent
\begin{minipage}{\linewidth}
\begin{lstlisting}
; containsPie? : list-of-string -> boolean
(define (containsPie? alst)
  (cond [(empty? alst) false]
        [(cons? alst) (or (string=? "pie" (first alst)) 
                          (containsPie? (rest alst)))]))
\end{lstlisting}
\label{template-example}
\end{minipage}

Templates are at the heart of the difference between \htdp and Rist's model. They scaffold development of code, giving students systematic rules to follow to get beyond a blank page when starting a programming problem (in Rist's creation state). \htdp teaches students concrete rules (not described here) for creating templates from datatypes; these rules scale to rich data structures including binary and n-ary trees, graphs, and other mutually-recursive data.  This set of uniform rules across datatypes provides a detailed \emph{process} for designing programs, particularly on new datatypes.  As students write multiple functions over the same datatype, templates can also serve as \emph{schemas} for other programs over that datatype.  Many students appear to internalize these schemas, without having to use the rules to create templates afresh each time.  

\subsection{Other Related Work}
\label{sec:other-rel-work}

Early studies by Pirolli \etal on novices learning recursive programming observed that people rely heavily on known solutions when developing new programs~\cite{Pirolli_Anderson_1985,Pirolli_Anderson_Farrell_1984}.  Novices modify already-learned solutions to fit the context of the new problem. Spohrer and Soloway's studies of the end-product programs of students and their talk-aloud protocols (verbal reports of planning, implementation, and debugging steps taken in programming a solution) echo this \cite{Spohrer_Soloway_1989}. They suggest that students, when writing code for a problem, either 
\begin{inparaenum}[(1)]
	\item use previously learned programming knowledge (programming plans) to write the code, or 
	\item translate relevant non-programming knowledge (non-programming plans) into code.
\end{inparaenum}
Students then proceed to a testing phase where they detect problems (or impasses) within their code, then enter a debugging phase to repair these impasses.

Spohrer and Soloway observed that most novice programming mistakes are due to difficulties with \emph{plan composition}, the putting together of program fragments to form a working program \cite{Spohrer_Soloway_1986}. They analyzed buggy programs in terms of their \emph{goals} relative to their \emph{plans} (groups of code that work together \cite{Shneiderman_1976, Soloway_Ehrlich_1984}). Goals and plans are cognitively plausible, deep structure knowledge that programmers have, based on knowledge of working programs. For example, programmers do not perceive an expression like \lstinline{sum += sum} merely as an assignment statement (code-specific: surface structure), but as part of a plan for a running sum (deep structure). Reasoning through a goal/plan perspective, and not merely through surface-structure language constructs, considers chunks of code as single units.  Spohrer and Soloway identified several issues that make plan composition difficult for novices, including cognitive load problems, unexpected cases, and optimization problems, among others \cite{Spohrer_Soloway_1986}.

% permit chunks of code to be accessed and reasoned about at once. In their analysis of these buggy programs, Spohrer and Soloway identified several problems that make plan composition difficult for novices, as well as construct-based problems that make the learning of of correct language construct semantics difficult (see \cite{Spohrer_Soloway_1986} for an in-depth list and definitions for construct-based and plan composition problems).

%% TODO: add related work on order of construction through Parson's problems
% no space -- will skip
%[FILL --- PARSONS PROBLEMS ---]

\section{An Exploratory Study}
\label{sec:study}

By design, \htdp templates should defer entry into Rist's ``creation'' mode, giving students a schema to retrieve based solely on the type of input to a function. If students have not solved a similar problem to the overall function, Rist's model predicts that students would then write focal computations.  However, Rist's notion that students write the focal computation then build context around it differs from the \htdp process, in which students would place focal computations either in template holes or in auxiliary (a.k.a. helper) functions.  Seeing what \htdp students do after writing templates should give insights into whether and how Rist's model, and the general idea of bottom-up programming, play out in the context of data-traversal schemas for recursive programs.

To better understand the interplay between Rist's model and \htdp, we conducted a study in a single \htdp-based CS1 class at a university in the USA. We gave students a programming problem over an input datatype they knew (a list of numbers), but that required additional programming techniques that they had not yet seen. This combination should have put students into Rist's creation mode (perhaps after retrieving the template).  We video-captured the students' programming sessions, then analyzed the videos to see when students wrote each of \htdp templates and Rist's focal computations, and how they edited around these pieces to complete the program. 

%% KATHI: didn't we also ask them survey questions about what they did?

In particular, we sought insight on the following questions:

\begin{enumerate}[itemsep=-3pt]
    \item When do \htdp-trained students use templates?
    \item How does Rist's idea of focal computations manifest in \htdp programs?
    %\item When do templates provide helpful scaffolding for novices during plan creation?
    \item How and when do \htdp students integrate focal computations into existing code?
    %\item What does the interaction between the focal expansion model and HtDP suggest about how novices can approach programming problems better?
\end{enumerate}

\noindent
Our questions attempt to avoid bias in favor of either Rist's model or \htdp's claimed benefits.  While we expected students to follow \htdp's process (as this was a key part of the course), we did not assume that students had internalized that process enough to actually do so. This is an exploratory study, asking whether (a) Rist's focal-expansion theory applies to functional programming through \htdp and (b) \htdp provides useful scaffolding to students on problems that require significantly different programming techniques than what they have already seen.

\subsection{The Problem: Adding Machine}
\label{sec:adding}

Our study used a programming problem called \Adding that consumes and produces a list of numbers:

\begin{quote}
Design a program called \texttt{adding-machine} that consumes a list of numbers and produces a list of the sums of each non-empty sublist separated by zeros. Ignore input elements that occur after the first occurrence of two consecutive zeros.\\

Example:\\
\lstinline{(adding-machine (list 1 2 0 7 0 5 4 1 0 0 6))} 
\\should produce \lstinline{(list 3 7 10)}
\end{quote}

\Adding involves four tasks:
\begin{enumerate}[label=\alph*),itemsep=-3pt]
	\item Ignoring data after the double-zero 
    \item Identifying sublists separated by single zeros
    \item Summing the elements in each sublist
    \item Building the output list from the sums of the sublists
\end{enumerate}

Students trained in functional programming would write a recursive solution.  Viable recursive approaches include:

\begin{itemize}
    \item \textbf{Reshape the data first}: The sublists in the input are embedded in a flat list of elements delimited by zeros. The input could be reshaped into a list of lists that omits the zeros. For example, the input \lstinline{(list 1 2 0 7 0 5 4 1 0 0 6)} could be reshaped as \lstinline{(list (list 1 2) (list 7) (list 5 4 1))}.  Separate functions would iterate over this list and sum each individual sublist. 

\item \textbf{Accumulate sums in a parameter}: The recursive function could take an additional parameter for the  sum of the current sublist. When a 0 is detected at the front of the input list, this parameter would be concatenated onto the result of processing the rest of the input list with the sum parameter initialized to 0.

    \item \textbf{Recur on a new list containing the sublist sum}: Since the recursive function takes the list to process as an input, the first position of the list can be used to store the running sublist sum.  For example, the call \lstinline{(adding-machine (list 1 2 0 5))} would generate the call \lstinline{(adding-machine (list 3 0 5))}. This approach is distinctly functional, as imperative solutions rarely modify a list mid-iteration.  Special care is required, however, if a sublist can sum to 0.
    
    \item \textbf{Recur on a new list that skips the first sublist}: A function could recur on the suffix of the list without the first sublist, using a separate function to produce the sum of the prefix corresponding to the first sublist.
    
\end{itemize}

Detecting the consecutive-zero termination pattern adds a bit of complexity, as solutions must check both the length of the remaining input (an input that doesn't contain the 00 pattern might have only one element) and the values of the first two elements.  Solutions can either truncate the input data at the double-0 in a separate pre-traversal, or integrate checking for the pattern into the core computation.

This problem seems excellent for studying the interactions between Rist's model and \htdp.  Lists of numbers are a familiar datatype to \htdp students: many will have already internalized the schema for flat lists.  Each of the high-level solutions outlined above, however, uses some more-advanced programming concepts: parameters that accumulate data or recur on something other than the rest of the list are covered after trees in \htdp. While basic mastery of lists would suffice to reshape data, students would not be exposed to the \emph{idea} of doing so until much later.  Thus, if \htdp students are given this problem after a couple of weeks of programming with lists, they will have a schema that appears to apply (the basic list template), but no experience with ``similar'' solutions that draw on these more advanced concepts.  Many students should end up in the plan-creation state while working on this problem, even if they initially retrieve the list-of-numbers template.

\subsection{Data Collection and Logistics}
\label{sec:logistics}
We collected data in Spring 2015 in a CS1 course taught using \htdp in Racket.  Neither author was on the course staff.  Students were given roughly 40 minutes to work on \Adding during a weekly lab session.  Each student used the SnagIt video-capture tool to record all activity within the window for the course IDE (DrRacket).  Students uploaded both the video and their final source-code file at the end of the lab session.
In total, 138 students submitted data; we randomly sampled 25 to analyze in this study.  In terms of final course grades, the sampled population earned 5 As, 13 Bs, 3 Cs, 3 fails, and 1 incomplete. We thus had a good mix of students relative to mastery of the material and likelihood of needing help.

We conducted the study five weeks into the academic term, after students had roughly 16 lectures (50-minutes each), 4 labs (50 minutes each), and 4 multi-exercise programming assignments for homework.  Before this point, the course had covered defining and calling functions, composing functions, conditionals, recursive functions over lists, and the \htdp design process (including test-first development of functions and templates, as described in \cref{sec:htdp}).  The students had written several functions over lists of numbers, strings, and records prior to doing the study.  The course had not yet covered trees, accumulating results of computations in additional parameters, or recursive calls on an argument other than the rest of the list.

% See: (cjzmuda 09:00)
\begin{figure}
\centering
\begin{tabular}{l} \hline
\begin{minipage}{0.95\columnwidth}
\begin{alltt}

1 Test AM 3
2 Template-list AM
3 AM buildsumlist (cons (helper1 first-L)
                        (AM rest-L))
4 Template-list helper1
5 helper1 sumelts (+ first-L (helper1 rest-L))
6 helper1 singlezero (= 0 first-L (AM rest-L))
7 AM singlezero (= 0 first-L)
8 Test helper1 3
\end{alltt}
\end{minipage}\\
\end{tabular}
\begin{tabular}{l}
\begin{minipage}{0.95\columnwidth}
\begin{lstlisting}
;; ListofNumber->ListofNumber
;; adds together elements of a sublist and returns them as a list
(check-expect 
     (adding-machine (list 1 2 0 7 0 5 4 1 0 0 6)) 
     (list 3 7 10))
(check-expect (adding-machine empty) empty)
(check-expect 
     (adding-machine (list 5 15 22 0 7 0 8 1)) 
     (list 42 7 9))

(define (adding-machine lon)
  (cond [(empty? lon) empty]
        [else (cons (findzero (first lon))
                    (adding-machine (rest lon)))]))

\end{lstlisting}
\end{minipage}
\end{tabular}
\vskip -1em
\caption{Sample coding sequence (top) and the actual program code (bottom)}
\label{table:codingsequence}
\vskip -1em
\end{figure}

\subsection{Coding Programming Edits}
When analyzing the videos, we recorded several events:

\begin{enumerate}[itemsep=-3pt]
    \item \textbf{Template use}: Students wrote an \htdp-prescribed template for a new function.
    \item \textbf{Task-specific computation}: Students wrote code related to one of the four problem tasks.  We recorded the actual code, the task it belongs to, and the function in which students put the code.  The tasks were recorded with the following labels:
    \begin{itemize}[leftmargin=*,itemsep=-2pt,topsep=0pt]
	\item[-] \textbf{singlezero}: handling single-zero delimiters
        \item[-] \textbf{doublezero}: handling the double-zero sentinel
        \item[-] \textbf{sumelts}: summing elements (of a sublist)
        \item[-] \textbf{buildsumlist}: building the list of sublist sums
	\end{itemize}
    \item \textbf{Test case use}: Students wrote test cases for a specific function.  We recorded the function name and number of tests written for it before the next event occurred
    \item \textbf{Other}: Students made edits that did not fall into one of these categories
\end{enumerate}

\Cref{table:codingsequence} shows an example of our analysis summary, along with its corresponding Racket program (the program shows the code as of step 3 in the summary). In the summary, {\tt AM} refers to the \Adding function. The student wrote another function named {\tt findzero}, replaced with the alias, {\tt helper1}, in the summary. Names for helper functions were replaced with aliases with the format {\tt helper<number>} to facilitate consistency in the coding as the students would sometimes change the names of helpers as they programmed their solutions. We produced a summary such as this for each of the 25 sampled programs.

\section{Analysis and Interpretation}
\label{sec:analysis}

None of the sampled students produced working solutions for \Adding, despite evidence that they used templates, developed focals, and tried to decompose the problem. 
Plan composition was the main hurdle, particularly when students tried to reuse template code inappropriately in multiple smaller-scale plans.

\lstset{frame=none}
% Users: cjzmuda 16:20, ahacker 31:20
\begin{table*}
\centering
\caption{Code samples: (Left) A task identified is pulled out into a separate function; (Right) Interleaving function calls within one function without decomposition.}
\begin{tabular}{|c|c|} \hline
\begin{minipage}{.5\textwidth}
\begin{lstlisting}
(define (adding-machine lon)
  (cond [(empty? lon) empty]
        [else (cons (adder lon)
                    (adding-machine (rest lon)))]))
                    
(define (adder lon)
  (cond [(empty? lon) 0]
        [(= 0 (first lon)) 
              (adding-machine (rest lon))
        [else (+ (first lon) (adder (rest lon)))]))
         
\end{lstlisting}
\end{minipage}
& 
\begin{minipage}{.5\textwidth}
\begin{lstlisting}
(define (adding-machine lon)
  (cond
    [(empty? lon) 0]
    [else
      (if (and (= (first lon) 0) (= (second lon) 0))
          (list 0)
          (+ (first lon)
             (adding-machine (rest lon))))]))
         
\end{lstlisting}
\end{minipage}\\ \hline
\end{tabular}
\label{table:codesamples}
\vskip -1em %\baselineskip
\end{table*}

All but one student (24 of 25) used the list-of-numbers template (same as the \lstinline{containsPie?} template in \cref{code:template-example}). From there, students took many approaches. \Cref{table:codesamples} shows two examples of the directions students took: the student on the left created a helper function to handle both single-zero delimiters and computing the sum of sublists, while the student on the right tried to handle both the double-zero and sum tasks within the template for \Adding. Both show plan-composition errors which we will explain as we describe general patterns in our data.

% FRANCIS-NOTE: This table shows what tasks were coded first and where (AM or Helper), not necessarily within the AM template. The 3 in "None/Other" wrote something else besides an identifiable computation
\begin{table}
\centering
\vskip -1em %\baselineskip
\caption[caption]{First tasks coded, with location \\\hspace{\textwidth}(\textit{Note: T = within template, NT = not in template})}
\label{tab:first-tasks}
\begin{tabular}{|l|c|c|} \hline
{\bf Task} & {\bf Within AM} & {\bf New Helper} \\ \hline
Sum sublist & 6 & 0 \\ \hline
Output list & 3 & 0 \\ \hline
Single zero & 9 (T) + 1 (NT) & 0 \\ \hline
Double zero & 1 & 2 \\ \hline
None/Other & \multicolumn{2}{c|}{3} \\ \hline
\end{tabular}
\vskip -1em %\baselineskip
\end{table}

\subsection{Focals After Templates?}

We hypothesized that students would enter creation mode after retrieving the template. As such, we looked at what code students wrote immediately after the template and where they put it, checking whether it captured focals.  As \Cref{tab:first-tasks} shows, all but 3 students wrote expressions that took on specific tasks.  Most (19) students put this new code into the template for the \Adding function. This matches focal-expansion theory, as well as \htdp pedagogy.  Most template holes get filled by focal-like expressions, though some decomposition (through helpers) also goes there.

Whether students had entered creation mode, however, isn't clear. Summing a list is a standard \htdp programming problem; students may have retrieved the \lstinline{+} code as done in \Cref{table:codesamples} (right). The single- and double-zero tasks are about termination of computations. As such, they resemble base cases of recursive functions (even though the usual base case of a recursive function on a list handles the empty list). Students may have retrieved the pattern of terminating a traversal, adapting it to recognize patterns of zeros.  The left student in \Cref{table:codesamples} wrote base-case-like code to catch the single-zero in the \lstinline{adder} function.

% FRANCIS-NOTE: The 21 students is 6 + 3 + 9 + 1 + 2. The 1 in 10 did not use templates.
Overall, 21 students who started with templates immediately filled in holes in that template with focal expressions for a specified program task and 2 began to decompose the problem by creating a helper function (in both cases to handle \textit{Double zero}). Of the remaining 4, one wrote a focal computation (\textit{Single zero}) within a non-template function, and 3 wrote something not clearly linked to a problem task. 

\subsection{Plan Composition}

Whether students retrieved or created plans for the problem tasks, they still had to compose them into an overall program. Here, students displayed significant difficulties.  Each solution in \Cref{table:codesamples} illustrates one of these challenges.

The solution on the right tries to integrate the plans for sum and double-zero by sharing template code: the template base-case (the \lstinline{empty?} check) returns a 0 as in the sum plan, while the ``new'' base case for double-zero returns a list (the output type of the overall function).  In attempting to share the recursive call (which would be syntactically identical in both the sum and truncate-at-00 plans), the student created an inconsistency in the output type of the program. Only 5 students even wrote both the sum and double-zero tasks; 3 of these put these tasks in the same function. Six students put both the single-zero and double-zero tasks in the same function, missing that each terminates a different other task (processing a sublist and identifying input to process, respectively).

In the solution on the left, the student tried to decompose the problem via a helper function.  The output task stayed in the main template, while the sum and single-zero tasks moved into the helper. This approach was on the right track, but had two key errors (aside from the missing plan for double-zero): the single-zero detection needed to be a base case (and return 0) in the helper, and the recursive call in the main function needed to take the suffix without the first sublist as input (rather than the entire rest of the list).  Despite these flaws, this student at least had a largely consistent view of the output type of each function (the erroneous single-zero base case answer notwithstanding). This reflects an understanding (missed in the solution on the right) that one use of template code can return only one type of output.

Eleven students moved the sum-sublist task into a helper (as in the solution on the left).  None modified the portion of the list passed on the recursive call, instead using the recursive call verbatim from the template.  Overall, 16 students created a helper function that took a list of numbers as input and included some program tasks. \Cref{tab:task-counts} summarizes the number of students who covered each task in each of helper functions, the main \Adding function, or both. 

\begin{table}
\centering
\vskip -0.5em
\caption{Where code for each task appears}
\label{tab:task-counts}
%\vskip\baselineskip
\begin{tabular}{|l|c|c|c|} \hline
{\bf Task} & {\bf Just in Main} & {\bf Just in Helper} & {\bf Both} \\ \hline
Single zero & 7 & 3 & 10 \\ \hline
Double zero & 4 & 1 & 2 \\ \hline
Sum sublist & 9 & 5 & 6 \\ \hline
Output list & 8 & 0 & 0 \\ \hline
\end{tabular}
\vskip -1em %\baselineskip
\end{table}

Even when students realized to create helpers, they often failed to effectively decompose the problem around those helpers: 12 of 25 created helpers that they never called from their main function. These helpers attempted combinations of the single-zero, double-zero, and sum-sublist tasks. This seems a different manifestation of thinking through focals: rather than integrate a focal computation into an existing function (their original templates), students tried to put them in separate functions.  This is not unreasonable, as each of these three tasks involves traversing a list, and students had been taught to use recursive functions to traverse lists. Of the students who created helper functions, 8 used templates in writing all helper functions (2 more did so sometimes), again suggesting a strong \htdp influence. These observations suggest that upon entering the creation state (after setting up templates), students resort to building their functions with a characteristic tinkering behavior \cite{Berland_Martin_Benton_Smith_Davis_2013} by patching up the holes in the template with familiar constructs and function calls, even when these result in output inconsistencies and essentially, plan composition problems.% This is characteristic of tinkering observed from novices.

Several students put the same tasks in both the main and helper functions (last column of \Cref{tab:task-counts}). Task-replication seems to depart from Rist's focal model, which suggests that students would write the focal computations once within their existing code, then build around them. This again reflects students' difficulties in decomposing the problem around the tasks.

% FRANCIS-NOTE:
% - 16 created a helper.
% - 11 (of the 16) had sumelts in those helpers
% - 7 (of the 11) called the helpers with sumelts in AM
% - 12 (of the 16) had instances of uncomposed helpers and these helpers had singlezero, doublezero, and sumelts tasks

\subsection{Advanced Techniques}

Both accumulating intermediate data in parameters and reshaping the data into a list of sublists are advanced patterns that students had not seen in the course (and thus could not have retrieved).  Only 1 student attempted to add a parameter for the running sublist sum.  Only 3 attempted to reshape the data; none did so successfully.  The coding sequences for the latter students suggests that as soon as students pulled out tasks to attempt to reshape the data, they proceeded into tinkering in and around these helpers.  
% See students 6, 8, 14
Students who tried this step (which would have been valuable had it worked) were clearly not thinking through focals, as data reshaping is not a computational task suggested in the problem statement (even though the problem hints at the flattened state of the data).

\section{Discussion and Future Work}
\label{sec:discuss}

The study in this paper was motivated by an apparent underlying tension between \htdp templates and Rist's model of bottom-up programming.  Rist's work suggests a cognitive process that students follow on new programming problems: write a core computation for a problem task (the focus), then augment the program to produce the data needed for the focal computation.  The potential tension with \htdp lies in the sub-expressions that templates introduce: these provide a \textit{context} into which students will place focal computations.  That context could either help or interfere with students' thinking as they integrate focals into a larger program. 

Our data suggest that students largely work through problem tasks: they write focal computations on the front elements of the input list, or create new functions for problem tasks.  They often appear to retrieve plans, in the form of individual recursive functions, for individual tasks (such as summing a list).  As such, our students often introduced focals as entire functions, not small expressions (as in Rist).  This may have deferred students' entry into creation mode, shifting more burden to plan composition.

Our students struggled to compose plans: some failed to adjust the portion of the list being recurred over, others tried to perform two tasks with different output types (summing and building lists) within the same recursive traversal (rather than accumulating the sum or creating a helper).  In both cases, our students used template expressions verbatim, rather than adjust them to the need of the computation at hand.  Given that they had not seen programs that adjusted template code, this behavior is not particularly surprising.  More generally, they lacked schemas for \emph{composition}, instead retrieving insufficient, lower-level, plans.

Does this mean that templates, and the context they provide, interfere more than help students?  Not necessarily.  The recursive calls are still needed, even if on slightly different inputs in some (but not all!) cases.  Students had simply not learned when to decompose problems into multiple instances of templates, and the templates failed to help them discover or resolve the issue.  Given prior work on the importance of retrievable schemas, \htdp's templates fit squarely within known results on how people program.  

Arguably, the key issue is that students are decomposing the problem \emph{on the fly around code they have already written}.  This arises whether students use \htdp (which prescribes the context) or bottom-up programming (in which students' existing code provides the context).  If the prior context isn't well-suited to the problem at hand, students will struggle with composition. Decomposing the \emph{problem} up front, into tasks that can be composed cleanly into a solution, should make the actual coding less error prone.  

Can we teach students to effectively decompose problems?  Both Rist's work and ours show that students think in terms of core program tasks.  Decomposing problems (rather than code) is about grouping the tasks of a problem into chunks that can reasonably be handled together.  What if we could teach students to use concrete examples to work out problem decompositions?  In the case of \Adding, for example, a student could start with

\lstinline{(adding-machine (list 1 2 0 7 0 5 4 1 0 0 6))}

\noindent
then write that this should produce the same answer as

\lstinline{(list (+ 1 2) (+ 7) (+ 5 4 1))}

\noindent
Realizing this might suggest specific functions that a student could write to transform the first expression into the second.  Something systematic such as this seems preferable to expecting students to just keep experimenting until their bottom-up process hits on a workable solution.  Just as students currently internalize schemas for writing code, we might expect they can learn to internalize schemas for decomposing problems through concrete examples.  The question at least warrants further study.

We suspect that some tension between Rist's model and \htdp arises from differences between functional and imperative programming.  
Deciding what Rist's model might mean within functional programming took considerable discussion among the authors.  Rist's description of ``bottom up'' references code organization typical of imperative programs: variable declaration and initialization at the top, computation in the middle, and results and output on the bottom.  Functional programs are organized differently: variables are initialized when functions are called, and outputs are typically composed from nested expressions within the middle of a function.  For this project, we chose to interpret ``bottom up'' as ``write contextual code after the focus".  Functional programs also tend to decompose problems into several functions, whereas imperative solutions for CS1-level programs often live within a single procedure.  This changes the decomposition patterns that students need for problems such as \Adding.  This raises various questions for how cognitive behavior in creation mode might differ based on the (affordances of the) programming language at hand.

% The use of the \htdp-prescribed templates provides the affordance of forming a context within which the identified computations may exist in. This context is beneficial for the learner. Functional forces bit more into decomposition, unless know advanced patterns, especially for extremely inexperienced novices, because the starting point does not have to be a blank slate --- the starting point is a skeleton that additionally makes traversing the input data ``automatic'' and that the skeleton may be made functional (within the problem) by adding in the computations. This is in contrast with Rist's focal expansion where students start with a blank slate, identify and implement a computation, and then build out the context for the computation. This on-the-fly process may lend itself to more tinkering, but the context will have to be built from scratch, which includes the tasks for traversing the input data.

\paragraph{Acknowledgments}
We thank Joe Beck for letting us collect data in his course and Mike Clancy for pointing us to the \Adding problem. This research is partially funded by the US NSF under grant number CCF1116539.

% The following commands produce the bibliography for the citations in your paper
\small
\bibliographystyle{abbrv}
\bibliography{sigproc}  
% sigproc.bib is the name of the Bibliography in this case
% Run: latex bibtex latex latex to resolve all references
%APPENDICES are optional
%\balancecolumns

\end{document}